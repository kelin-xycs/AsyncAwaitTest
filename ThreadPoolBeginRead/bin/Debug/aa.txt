漫谈 C++ 的 内存堆 实现原理
如果我来设计 C++ 的 内存堆 ， 我会这样设计 ：                     

 

进程 首先会跟 操作系统 要 一块大内存区域 ， 我称之为 Division ， 简称 div 。 

然后 ， 将这块 div 作为 堆 ， 就可以开始 从堆里分配 内存 了 。

 

堆里 未分配 可使用 的 内存区域 称之为 Free Space ， 一开始的时候 ， div 里 只有一个 Free Space ， 就是 整个 div 。

如果 只分配 不回收 的话 ， div 里 永远都只有一个 Free Space 。 随着 分配 和 回收 ， div 里会产生多个 Free Space 。

我们需要建立一张 堆表 来 记录 Free Space ， 这样才能知道 每一次分配 应该 到 哪个 Free Space 里 分配 。

 

堆表 应该是一个 链表 ， 便于 插入 和 删除 表项 。 表项 就是 Free Space ， 或者说 表项 描述 Free Space 。 所以 表项 会包含 2 个 字段 ， 一个是 Free Space 的 起始地址 ， 另一个是 Free Space 的 结束地址 。

同时 还应该有一个 指针 ， 指向 当前在用的 表项 ， 一次分配 就是 在 当前表项 指向的 Free Space 里分配 ， 如果 当前 Free Space 的 大小 不足以分配本次申请的 内存块大小 ， 则 将指针 指向 当前 Free Space 的 下一个 Free Space 。 如果 下一个 Free Space 的 大小也不够 ， 那么 就继续指向 下一个 Free Space 。 如此循环 。

 

那如果 最后一个 Free Space 的大小也不够的话 ， 就需要向 操作系统 要 一个 新的 div 。 注意 ， Free Space 只能属于一个 div ， 不能跨 div 。

 

如果 堆里的 Free Space 比较多 ， 那么 如果 Free Space 大小不够 ， 有可能会连续找多个 Free Space 才找到 足够大小的 Free Space ， 这里就产生了一个 性能问题 。

最坏的情况 ， “从头找到尾” ， 到最后一个 Free Space 才足够大小 。 但 ， 这还不是最坏的 ^^ ， 如果最后一个 Free Space 的大小也不够的话 ， 就要跟操作系统要一个 新的 div ， 这好像要 “更坏” 一点 。  ^^

 

还有一个重要的问题需要考虑 ， 就是 如果 跟操作系统要了 1 个以上的 div ， 如果长期占用 ， 这是一个不小的空间 。 那么 ， 要怎样在 div 中的内存全部都已经回收 （整个 div 是一个 Free Space） 的时候 ， 将 div 归还操作系统呢 ？  

 

可以通过一个 计数器 。 可以为每个 div 设置一个 计数器 ， 同时在 堆表项 里增加一个 字段 ： Free Space 所在的 div 。

这样 ， 每次 分配 的时候 就在 计数器 里 加 1 ， 每次 回收 就让 计数器 减 1 ， 如果 减 1 以后 计数器 的 值 是 0 ， 那么就说明 div 已经全部回收 ， 可以将 div 归还 操作系统 。

 

最后 ， 我很好奇 ， C++ 是怎么解决 内存碎片 的问题的 。 哈哈哈哈

 

突然发现 堆 的 管理算法 有点 小复杂 ， 如果 堆表 本身占用的内存空间是 固定 的 ， 那么如果 Free Space 的数量超出了 对表 的空间所能存储的数量 ， 这就有问题 ， 如果舍弃一些 比较小的 Free Space ， 会造成 内存泄露 。
